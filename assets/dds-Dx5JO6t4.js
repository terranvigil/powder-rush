import{A as T,R as pt,b as Ft,I as Ct,_ as dt,c as H,C as w}from"./index-DJSMGTKq.js";import{C as _t}from"./cubemapToSphericalPolynomial-Cf8F8Btl.js";let X,Y;function k(u){X||(X=new Float32Array(1),Y=new Int32Array(X.buffer)),X[0]=u;const a=Y[0];let t=a>>16&32768,e=a>>12&2047;const s=a>>23&255;return s<103?t:s>142?(t|=31744,t|=(s==255?0:1)&&a&8388607,t):s<113?(e|=2048,t|=(e>>114-s)+(e>>113-s&1),t):(t|=s-112<<10|e>>1,t+=e&1,t)}function U(u){const a=(u&32768)>>15,t=(u&31744)>>10,e=u&1023;return t===0?(a?-1:1)*Math.pow(2,-14)*(e/Math.pow(2,10)):t==31?e?NaN:(a?-1:1)*(1/0):(a?-1:1)*Math.pow(2,t-15)*(1+e/Math.pow(2,10))}function Gt(u){const a=u.split("?")[0],t=a.lastIndexOf(".");return t>-1?a.substring(t).toLowerCase():""}T.prototype._partialLoadFile=function(u,a,t,e,s=null){const i=r=>{t[a]=r,t._internalCount++,t._internalCount===6&&e(t)},A=(r,c)=>{s&&r&&s(r.status+" "+r.statusText,c)};this._loadFile(u,i,void 0,void 0,!0,A)};T.prototype._cascadeLoadFiles=function(u,a,t,e=null){const s=[];s._internalCount=0;for(let i=0;i<6;i++)this._partialLoadFile(t[i],i,s,a,e)};T.prototype._cascadeLoadImgs=function(u,a,t,e,s=null,i){const A=[];A._internalCount=0;for(let r=0;r<6;r++)this._partialLoadImg(e[r],r,A,u,a,t,s,i)};T.prototype._partialLoadImg=function(u,a,t,e,s,i,A=null,r){const c=pt();Ft(u,l=>{t[a]=l,t._internalCount++,e&&e.removePendingData(c),t._internalCount===6&&i&&i(s,t)},(l,f)=>{e&&e.removePendingData(c),A&&A(l,f)},e?e.offlineProvider:null,r),e&&e.addPendingData(c)};T.prototype.createCubeTextureBase=function(u,a,t,e,s=null,i=null,A,r=null,c=!1,n=0,o=0,l=null,f=null,G=null,p=!1,F=null){const y=l||new Ct(this,7);y.isCube=!0,y.url=u,y.generateMipMaps=!e,y._lodGenerationScale=n,y._lodGenerationOffset=o,y._useSRGBBuffer=!!p&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!e),y!==l&&(y.label=u.substring(0,60)),this._doNotHandleContextLost||(y._extension=r,y._files=t,y._buffer=F);const _=u;this._transformTextureUrl&&!l&&(u=this._transformTextureUrl(u));const B=r??Gt(u),P=dt(B),I=(h,m)=>{u===_?i&&h&&i(h.status+" "+h.statusText,m):(H.Warn(`Failed to load ${u}, falling back to the ${_}`),this.createCubeTextureBase(_,a,t,!!e,s,i,A,r,c,n,o,y,f,G,p,F))};if(P)P.then(h=>{const m=d=>{f&&f(y,d),h.loadCubeData(d,y,c,s,i)};F?m(F):t&&t.length===6?h.supportCascades?this._cascadeLoadFiles(a,d=>m(d.map(g=>new Uint8Array(g))),t,i):i?i("Textures type does not support cascades."):H.Warn("Texture loader does not support cascades."):this._loadFile(u,d=>m(new Uint8Array(d)),void 0,void 0,!0,I)});else{if(!t||t.length===0)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(a,y,(h,m)=>{G&&G(h,m)},t,i)}return this._internalTexturesCache.push(y),y};const ht=542327876,Z=131072,v=512,S=4,q=64,tt=131072;function W(u){return u.charCodeAt(0)+(u.charCodeAt(1)<<8)+(u.charCodeAt(2)<<16)+(u.charCodeAt(3)<<24)}function xt(u){return String.fromCharCode(u&255,u>>8&255,u>>16&255,u>>24&255)}const et=W("DXT1"),rt=W("DXT3"),at=W("DXT5"),E=W("DX10"),nt=113,st=116,ot=2,ft=10,mt=88,V=31,bt=0,Bt=1,it=2,ct=3,$=4,lt=7,j=20,ut=21,Rt=22,Ot=23,wt=24,Ut=25,It=26,gt=28,Lt=32;class C{static GetDDSInfo(a){const t=new Int32Array(a.buffer,a.byteOffset,V),e=new Int32Array(a.buffer,a.byteOffset,V+4);let s=1;t[it]&Z&&(s=Math.max(1,t[lt]));const i=t[ut],A=i===E?e[Lt]:0;let r=0;switch(i){case nt:r=2;break;case st:r=1;break;case E:if(A===ft){r=2;break}if(A===ot){r=1;break}}return{width:t[$],height:t[ct],mipmapCount:s,isFourCC:(t[j]&S)===S,isRGB:(t[j]&q)===q,isLuminance:(t[j]&tt)===tt,isCube:(t[gt]&v)===v,isCompressed:i===et||i===rt||i===at,dxgiFormat:A,textureType:r}}static _GetHalfFloatAsFloatRGBAArrayBuffer(a,t,e,s,i,A){const r=new Float32Array(s),c=new Uint16Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=U(c[f]),r[n+1]=U(c[f+1]),r[n+2]=U(c[f+2]),C.StoreLODInAlphaChannel?r[n+3]=A:r[n+3]=U(c[f+3]),n+=4}return r}static _GetHalfFloatRGBAArrayBuffer(a,t,e,s,i,A){if(C.StoreLODInAlphaChannel){const r=new Uint16Array(s),c=new Uint16Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=c[f],r[n+1]=c[f+1],r[n+2]=c[f+2],r[n+3]=k(A),n+=4}return r}return new Uint16Array(i,e,s)}static _GetFloatRGBAArrayBuffer(a,t,e,s,i,A){if(C.StoreLODInAlphaChannel){const r=new Float32Array(s),c=new Float32Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=c[f],r[n+1]=c[f+1],r[n+2]=c[f+2],r[n+3]=A,n+=4}return r}return new Float32Array(i,e,s)}static _GetFloatAsHalfFloatRGBAArrayBuffer(a,t,e,s,i,A){const r=new Uint16Array(s),c=new Float32Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++)r[n]=k(c[n]),r[n+1]=k(c[n+1]),r[n+2]=k(c[n+2]),C.StoreLODInAlphaChannel?r[n+3]=k(A):r[n+3]=k(c[n+3]),n+=4;return r}static _GetFloatAsUIntRGBAArrayBuffer(a,t,e,s,i,A){const r=new Uint8Array(s),c=new Float32Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=w(c[f])*255,r[n+1]=w(c[f+1])*255,r[n+2]=w(c[f+2])*255,C.StoreLODInAlphaChannel?r[n+3]=A:r[n+3]=w(c[f+3])*255,n+=4}return r}static _GetHalfFloatAsUIntRGBAArrayBuffer(a,t,e,s,i,A){const r=new Uint8Array(s),c=new Uint16Array(i,e);let n=0;for(let o=0;o<t;o++)for(let l=0;l<a;l++){const f=(l+o*a)*4;r[n]=w(U(c[f]))*255,r[n+1]=w(U(c[f+1]))*255,r[n+2]=w(U(c[f+2]))*255,C.StoreLODInAlphaChannel?r[n+3]=A:r[n+3]=w(U(c[f+3]))*255,n+=4}return r}static _GetRGBAArrayBuffer(a,t,e,s,i,A,r,c,n){const o=new Uint8Array(s),l=new Uint8Array(i,e);let f=0;for(let G=0;G<t;G++)for(let p=0;p<a;p++){const F=(p+G*a)*4;o[f]=l[F+A],o[f+1]=l[F+r],o[f+2]=l[F+c],o[f+3]=l[F+n],f+=4}return o}static _ExtractLongWordOrder(a){return a===0||a===255||a===-16777216?0:1+C._ExtractLongWordOrder(a>>8)}static _GetRGBArrayBuffer(a,t,e,s,i,A,r,c){const n=new Uint8Array(s),o=new Uint8Array(i,e);let l=0;for(let f=0;f<t;f++)for(let G=0;G<a;G++){const p=(G+f*a)*3;n[l]=o[p+A],n[l+1]=o[p+r],n[l+2]=o[p+c],l+=3}return n}static _GetLuminanceArrayBuffer(a,t,e,s,i){const A=new Uint8Array(s),r=new Uint8Array(i,e);let c=0;for(let n=0;n<t;n++)for(let o=0;o<a;o++){const l=o+n*a;A[c]=r[l],c++}return A}static UploadDDSLevels(a,t,e,s,i,A,r=-1,c,n=!0){let o=null;s.sphericalPolynomial&&(o=[]);const l=!!a.getCaps().s3tc;t.generateMipMaps=i;const f=new Int32Array(e.buffer,e.byteOffset,V);let G,p,F,y=0,_,B,P,I,h=0,m=1;if(f[bt]!==ht){H.Error("Invalid magic number in DDS header");return}if(!s.isFourCC&&!s.isRGB&&!s.isLuminance){H.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");return}if(s.isCompressed&&!l){H.Error("Compressed textures are not supported on this platform.");return}let d=f[Rt];_=f[Bt]+4;let g=!1;if(s.isFourCC)switch(G=f[ut],G){case et:m=8,h=33777;break;case rt:m=16,h=33778;break;case at:m=16,h=33779;break;case nt:g=!0,d=64;break;case st:g=!0,d=128;break;case E:{_+=20;let b=!1;switch(s.dxgiFormat){case ft:g=!0,d=64,b=!0;break;case ot:g=!0,d=128,b=!0;break;case mt:s.isRGB=!0,s.isFourCC=!1,d=32,b=!0;break}if(b)break}default:H.Error(["Unsupported FourCC code:",xt(G)]);return}const J=C._ExtractLongWordOrder(f[Ot]),K=C._ExtractLongWordOrder(f[wt]),Q=C._ExtractLongWordOrder(f[Ut]),At=C._ExtractLongWordOrder(f[It]);g&&(h=a._getRGBABufferInternalSizedFormat(s.textureType)),P=1,f[it]&Z&&i!==!1&&(P=Math.max(1,f[lt]));const yt=c||0,M=a.getCaps();for(let b=yt;b<A;b++){for(p=f[$],F=f[ct],I=0;I<P;++I){if(r===-1||r===I){const x=r===-1?I:0;if(!s.isCompressed&&s.isFourCC){t.format=5,y=p*F*4;let R=null;if(a._badOS||a._badDesktopOS||!M.textureHalfFloat&&!M.textureFloat)d===128?(R=C._GetFloatAsUIntRGBAArrayBuffer(p,F,e.byteOffset+_,y,e.buffer,x),o&&x==0&&o.push(C._GetFloatRGBAArrayBuffer(p,F,e.byteOffset+_,y,e.buffer,x))):d===64&&(R=C._GetHalfFloatAsUIntRGBAArrayBuffer(p,F,e.byteOffset+_,y,e.buffer,x),o&&x==0&&o.push(C._GetHalfFloatAsFloatRGBAArrayBuffer(p,F,e.byteOffset+_,y,e.buffer,x))),t.type=0;else{const D=M.textureFloat&&(n&&M.textureFloatLinearFiltering||!n),N=M.textureHalfFloat&&(n&&M.textureHalfFloatLinearFiltering||!n),z=(d===128||d===64&&!N)&&D?1:(d===64||d===128&&!D)&&N?2:0;let L,O=null;switch(d){case 128:{switch(z){case 1:L=C._GetFloatRGBAArrayBuffer,O=null;break;case 2:L=C._GetFloatAsHalfFloatRGBAArrayBuffer,O=C._GetFloatRGBAArrayBuffer;break;case 0:L=C._GetFloatAsUIntRGBAArrayBuffer,O=C._GetFloatRGBAArrayBuffer;break}break}default:{switch(z){case 1:L=C._GetHalfFloatAsFloatRGBAArrayBuffer,O=null;break;case 2:L=C._GetHalfFloatRGBAArrayBuffer,O=C._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:L=C._GetHalfFloatAsUIntRGBAArrayBuffer,O=C._GetHalfFloatAsFloatRGBAArrayBuffer;break}break}}t.type=z,R=L(p,F,e.byteOffset+_,y,e.buffer,x),o&&x==0&&o.push(O?O(p,F,e.byteOffset+_,y,e.buffer,x):R)}R&&a._uploadDataToTextureDirectly(t,R,b,x)}else if(s.isRGB)t.type=0,d===24?(t.format=4,y=p*F*3,B=C._GetRGBArrayBuffer(p,F,e.byteOffset+_,y,e.buffer,J,K,Q),a._uploadDataToTextureDirectly(t,B,b,x)):(t.format=5,y=p*F*4,B=C._GetRGBAArrayBuffer(p,F,e.byteOffset+_,y,e.buffer,J,K,Q,At),a._uploadDataToTextureDirectly(t,B,b,x));else if(s.isLuminance){const R=a._getUnpackAlignement(),D=p;y=Math.floor((p+R-1)/R)*R*(F-1)+D,B=C._GetLuminanceArrayBuffer(p,F,e.byteOffset+_,y,e.buffer),t.format=1,t.type=0,a._uploadDataToTextureDirectly(t,B,b,x)}else y=Math.max(4,p)/4*Math.max(4,F)/4*m,B=new Uint8Array(e.buffer,e.byteOffset+_,y),t.type=0,a._uploadCompressedDataToTextureDirectly(t,h,p,F,B,b,x)}_+=d?p*F*(d/8):y,p*=.5,F*=.5,p=Math.max(1,p),F=Math.max(1,F)}if(c!==void 0)break}o&&o.length>0?s.sphericalPolynomial=_t.ConvertCubeMapToSphericalPolynomial({size:f[$],right:o[0],left:o[1],up:o[2],down:o[3],front:o[4],back:o[5],format:5,type:1,gammaSpace:!1}):s.sphericalPolynomial=void 0}}C.StoreLODInAlphaChannel=!1;export{C as DDSTools};
