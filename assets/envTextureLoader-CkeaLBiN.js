const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/rgbdDecode.fragment-CkAA9yyF.js","assets/index-DJSMGTKq.js","assets/helperFunctions-Bx7vtHDT.js","assets/rgbdDecode.fragment-J-VNbnzG.js"])))=>i.map(i=>d[i]);
import{B as L,c as U,a as B,V as d,I as S,T as z,e as V,f as C,P as G}from"./index-DJSMGTKq.js";import"./dumpTools-C7vORUO8.js";import{C as k}from"./cubemapToSphericalPolynomial-Cf8F8Btl.js";L.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)};Object.defineProperty(L.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=k.ConvertCubeMapTextureToSphericalPolynomial(this),this._texture._sphericalPolynomialPromise===null?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then(e=>{this._texture._sphericalPolynomial=e,this._texture._sphericalPolynomialComputed=!0})),null}return null},set:function(e){this._texture&&(this._texture._sphericalPolynomial=e)},enumerable:!0,configurable:!0});const M="image/png",F=2,D=[134,22,135,150,246,214,150,54];function H(e){const a=new DataView(e.buffer,e.byteOffset,e.byteLength);let t=0;for(let o=0;o<D.length;o++)if(a.getUint8(t++)!==D[o])return U.Error("Not a babylon environment map"),null;let n="",i=0;for(;i=a.getUint8(t++);)n+=String.fromCharCode(i);let r=JSON.parse(n);return r=v(r),r.binaryDataPosition=t,r.specular&&(r.specular.lodGenerationScale=r.specular.lodGenerationScale||.8),r}function v(e){if(e.version>F)throw new Error(`Unsupported babylon environment map version "${e.version}". Latest supported version is "${F}".`);return e.version===2||(e={...e,version:2,imageType:M}),e}function N(e,a){a=v(a);const t=a.specular;let n=Math.log2(a.width);if(n=Math.round(n)+1,t.mipmaps.length!==6*n)throw new Error(`Unsupported specular mipmaps number "${t.mipmaps.length}"`);const i=new Array(n);for(let r=0;r<n;r++){i[r]=new Array(6);for(let o=0;o<6;o++){const l=t.mipmaps[r*6+o];i[r][o]=new Uint8Array(e.buffer,e.byteOffset+a.binaryDataPosition+l.position,l.length)}}return i}function $(e,a){a=v(a);const t=new Array(6),n=a.irradiance?.irradianceTexture;if(n){if(n.faces.length!==6)throw new Error(`Incorrect irradiance texture faces number "${n.faces.length}"`);for(let i=0;i<6;i++){const r=n.faces[i];t[i]=new Uint8Array(e.buffer,e.byteOffset+a.binaryDataPosition+r.position,r.length)}}return t}function Y(e,a,t){t=v(t);const n=t.specular;if(!n)return Promise.resolve([]);e._lodGenerationScale=n.lodGenerationScale;const i=[],r=N(a,t);i.push(j(e,r,t.imageType));const o=t.irradiance?.irradianceTexture;if(o){const l=$(a,t);i.push(W(e,l,o.size,t.imageType))}return Promise.all(i)}function O(e,a,t,n,i,r,o,l,g,f,T){return new Promise((m,A)=>{if(t){const h=a.createTexture(null,!0,!0,null,1,null,s=>{A(s)},e);n?.onEffectCreatedObservable.addOnce(s=>{s.executeWhenCompiled(()=>{n.externalTextureSamplerBinding=!0,n.onApply=c=>{c._bindTexture("textureSampler",h),c.setFloat2("scale",1,a._features.needsInvertingBitmap&&e instanceof ImageBitmap?-1:1)},a.scenes.length&&(a.scenes[0].postProcessManager.directRender([n],f,!0,r,o),a.restoreDefaultFramebuffer(),h.dispose(),URL.revokeObjectURL(i),m())})})}else{if(a._uploadImageToTexture(T,e,r,o),l){const h=g[o];h&&a._uploadImageToTexture(h._texture,e,r,0)}m()}})}async function j(e,a,t=M){const n=e.getEngine();e.format=5,e.type=0,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,n.updateTextureSamplingMode(3,e),await E(e,a,!0,t),e.isReady=!0}async function W(e,a,t,n=M){const i=e.getEngine(),r=new S(i,5),o=new L(i,r);e._irradianceTexture=o,r.isCube=!0,r.format=5,r.type=0,r.generateMipMaps=!0,r._cachedAnisotropicFilteringLevel=null,r.generateMipMaps=!0,r.width=t,r.height=t,i.updateTextureSamplingMode(3,r),await E(r,[a],!1,n),i.generateMipMapsForCubemap(r),r.isReady=!0}async function E(e,a,t,n=M){if(!z.IsExponentOfTwo(e.width))throw new Error("Texture size must be a power of two");const i=V(e.width)+1,r=e.getEngine();let o=!1,l=!1,g=null,f=null,T=null;const m=r.getCaps();m.textureLOD?r._features.supportRenderAndCopyToLodForFloatTextures?m.textureHalfFloatRender&&m.textureHalfFloatLinearFiltering?(o=!0,e.type=2):m.textureFloatRender&&m.textureFloatLinearFiltering&&(o=!0,e.type=1):o=!1:(o=!1,l=t);let A=0;if(o)r.isWebGPU?(A=1,await C(()=>import("./rgbdDecode.fragment-CkAA9yyF.js"),__vite__mapDeps([0,1,2]))):await C(()=>import("./rgbdDecode.fragment-J-VNbnzG.js"),__vite__mapDeps([3,1])),g=new G("rgbdDecode","rgbdDecode",null,null,1,null,3,r,!1,void 0,e.type,void 0,null,!1,void 0,A),e._isRGBD=!1,e.invertY=!1,f=r.createRenderTargetCubeTexture(e.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:e.type,format:5});else if(e._isRGBD=!0,e.invertY=!0,l){T={};const c=e._lodGenerationScale,y=e._lodGenerationOffset;for(let u=0;u<3;u++){const w=1-u/2,p=y,R=(i-1)*c+y,I=p+(R-p)*w,b=Math.round(Math.min(Math.max(I,0),R)),P=new S(r,2);P.isCube=!0,P.invertY=!0,P.generateMipMaps=!1,r.updateTextureSamplingMode(2,P);const x=new L(null);switch(x._isCube=!0,x._texture=P,T[b]=x,u){case 0:e._lodTextureLow=x;break;case 1:e._lodTextureMid=x;break;case 2:e._lodTextureHigh=x;break}}}const h=[];for(let s=0;s<a.length;s++)for(let c=0;c<6;c++){const y=a[s][c],u=new Blob([y],{type:n}),_=URL.createObjectURL(u);let w;if(r._features.forceBitmapOverHTMLImageElement)w=r.createImageBitmap(u,{premultiplyAlpha:"none"}).then(p=>O(p,r,o,g,_,c,s,l,T,f,e));else{const p=new Image;p.src=_,w=new Promise((R,I)=>{p.onload=()=>{O(p,r,o,g,_,c,s,l,T,f,e).then(()=>R()).catch(b=>{I(b)})},p.onerror=b=>{I(b)}})}h.push(w)}if(await Promise.all(h),a.length<i){let s;const c=Math.pow(2,i-1-a.length),y=c*c*4;switch(e.type){case 0:{s=new Uint8Array(y);break}case 2:{s=new Uint16Array(y);break}case 1:{s=new Float32Array(y);break}}for(let u=a.length;u<i;u++)for(let _=0;_<6;_++)r._uploadArrayBufferViewToTexture(f?.texture||e,s,_,u)}if(f){const s=e._irradianceTexture;e._irradianceTexture=null,r._releaseTexture(e),f._swapAndDie(e),e._irradianceTexture=s}g&&g.dispose(),l&&(e._lodTextureHigh&&e._lodTextureHigh._texture&&(e._lodTextureHigh._texture.isReady=!0),e._lodTextureMid&&e._lodTextureMid._texture&&(e._lodTextureMid._texture.isReady=!0),e._lodTextureLow&&e._lodTextureLow._texture&&(e._lodTextureLow._texture.isReady=!0))}function J(e,a){a=v(a);const t=a.irradiance;if(!t)return;const n=new B;d.FromArrayToRef(t.x,0,n.x),d.FromArrayToRef(t.y,0,n.y),d.FromArrayToRef(t.z,0,n.z),d.FromArrayToRef(t.xx,0,n.xx),d.FromArrayToRef(t.yy,0,n.yy),d.FromArrayToRef(t.zz,0,n.zz),d.FromArrayToRef(t.yz,0,n.yz),d.FromArrayToRef(t.zx,0,n.zx),d.FromArrayToRef(t.xy,0,n.xy),e._sphericalPolynomial=n}class X{constructor(){this.supportCascades=!1}loadCubeData(a,t,n,i,r){if(Array.isArray(a))return;const o=H(a);if(o){t.width=o.width,t.height=o.width;try{J(t,o),Y(t,a,o).then(()=>{t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),i&&i()},l=>{r?.("Can not upload environment levels",l)})}catch(l){r?.("Can not upload environment file",l)}}else r&&r("Can not parse the environment file",null)}loadData(){throw".env not supported in 2d."}}export{X as _ENVTextureLoader};
